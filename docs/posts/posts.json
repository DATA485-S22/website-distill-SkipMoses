[
  {
    "path": "posts/2022-03-22-linear-regression/",
    "title": "Linear Regression",
    "description": "A tutorial for Linear Regression using tidyverse.",
    "author": [
      {
        "name": "Skip Moses",
        "url": "https://example.com/norajones"
      }
    ],
    "date": "2022-03-22",
    "categories": [],
    "contents": "\nWhat is Linear Regression?\nOften the goal of data science is to make predictions from data. This will take the form of fitting our data to a model;\n\\[y = ax + b + \\epsilon\\]\nwhere \\(y\\) is our output/response variable, \\(x\\) is our input/predictor variable, \\(b\\) is a constant and \\(\\epsilon\\) is our irreducible error. Thus, if we have data \\(\\hat{y}\\) and \\(\\hat{x}\\), then fitting this data corresponds to finding a suitable \\(a\\) and \\(b\\).\n\n\n\nHere we have created some synthetic data. We can see there should be a line that can approximate this data (it was built to be so). But the question remains, how do we decide which line is best. The blue and green line seem better than the red line, but how do we quantify this?\nOne approach is to select the line that minimizes the aggregate distance from data points to our model. More rigorously, the line of best fit (our \\(a\\) and \\(b\\)) will be such the quantity\n\\[\\sum_{i=1}^N\\vert a\\hat{x} + b - \\hat{y}(\\hat{x}) \\vert \\]\nThe proof of the validity of this is beyond the scope of this tutorial.\nLinear Regression in R with tidyverse\nFortunately, there are several computer software packages capable of finding lines of best fit without any tedious calculations by hand. We will focus on the tidyverse implementation in r.\nThe first thing we need to do is install the package and load it.\n\n\n\nNext, we need to tell r we want to create a linear model using regression. Essentially, we a creating an interface for our model, that will work nicely with a wide range of packages.\n\n\n\nNow, we will specify an engine for fitting the model. This tells r what software should be used to fit the model. Some examples are Stan and glmnet, but we will simply use the ‘lm’ function.\n\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n\nLastly, in some cases the predictor does not represent a numeric outcome. In this case, we need to specify the the mode (regression or classification). Presently, since we are using linear regression, there is only one mode and we do not need to specify it.\nNow, that our model interface is created, we can use it to fit our data.\n\nparsnip model object\n\nFit time:  4ms \n\nCall:\nstats::lm(formula = yhat ~ x1, data = data)\n\nCoefficients:\n(Intercept)           x1  \n    120.764        4.605  \n\n\n[1] \"list\"\n\nNotice the output of fit is a list containing ‘spec’, ‘fit’, ‘preproc’ and ‘elapsed’. We will only deal with ‘fit’ in this tutorial.\nIn order to get more detailed picture of our model we can call the summary function. We use the ‘pluck()’ function to pull the ‘fit’ element from our output and create a summary.\n\n\nCall:\nstats::lm(formula = yhat ~ x1, data = data)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-38.57 -15.24   0.15  14.31  66.25 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 120.7644    15.2940   7.896 4.22e-12 ***\nx1            4.6047     0.2997  15.364  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 20.54 on 98 degrees of freedom\nMultiple R-squared:  0.7066,    Adjusted R-squared:  0.7037 \nF-statistic: 236.1 on 1 and 98 DF,  p-value: < 2.2e-16\n\nAlternatively, we can use the tidy() function to get a view our estimated parameters in a nice table.\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic  p.value\n  <chr>          <dbl>     <dbl>     <dbl>    <dbl>\n1 (Intercept)   121.      15.3        7.90 4.22e-12\n2 x1              4.60     0.300     15.4  7.60e-28\n\nIf we want to analyze the model statistics we call the glance() function.\n\n# A tibble: 1 × 12\n  r.squared adj.r.squared sigma statistic  p.value    df logLik   AIC\n      <dbl>         <dbl> <dbl>     <dbl>    <dbl> <dbl>  <dbl> <dbl>\n1     0.707         0.704  20.5      236. 7.60e-28     1  -443.  892.\n# … with 4 more variables: BIC <dbl>, deviance <dbl>,\n#   df.residual <int>, nobs <int>\n\n\n\n\n",
    "preview": "posts/2022-03-22-linear-regression/linear-regression_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2022-03-22T21:14:27-07:00",
    "input_file": "linear-regression.knit.md"
  },
  {
    "path": "posts/2022-02-09-my-name/",
    "title": "Extended Euclidean algorithm.",
    "description": "Sagemath code for an extended euclidean algorithm.",
    "author": [
      {
        "name": "Skip Moses",
        "url": "https://example.com/norajones"
      }
    ],
    "date": "2022-02-09",
    "categories": [],
    "contents": "\nFor my cryptography class we have code the Extended Euclidean Algrorithm. The Euclidean algorithm returns the greatest common divisor of two numbers.\nLet \\(a\\), \\(b \\in \\mathbb{Z}\\) be not both divisible by zero.\n\\[gcd(a,b) = \\text{ max}\\{d \\in \\mathbb{Z} : \\text{ } d\\vert a \\text{ and } d\\vert b \\}\\]\nIf we compute a \\(gcd\\) by hand we might proceed as follows assuming \\(b < a\\):\n\\[\\begin{align}\na &= bq_1 + r_1 &&0 \\leq r_1 \\leq b \\\\\nb &= q_2r_1 + r_2 &&0 \\leq r_2 \\leq r_1 \\\\\n\\vdots \\\\\nr_{n-2} &=  q_{n}r_{n-1} + r_n && 0 \\leq r_n < r_{n-1} \\\\\nr_{n-1} &=  q_{n+1}r_n + 0\n\\end{align}\\]\nFrom this process the last non zero \\(r_i\\) will be the gcd of \\(a\\) and \\(b\\).\nThis algorithm can be implemented with recursion as follows:\ndef my_gcd(a,b):\n     if a%b == 0:\n            return a\n     return my_gcd(b, a%b)\nGiven \\(a\\) and \\(b \\in \\mathbb{Z}\\) there is \\(S\\) and \\(T \\in \\mathbb{Z}\\) such that\n\\[\\begin{align}\na\\cdot S + b \\cdot T = \\text{gcd}(a,b)\n\\end{align}\\]\nWe need an iterative process to keep track of the \\(S\\) and \\(T\\) for the Extended Euclidean Algorithm.\n\\[\\begin{align}\nr_{i-2} &= S_{i-2}a + T_{i-2}b \\\\\nr_{i-1} &= S_{i-1}a + T_{i-1}\n\\end{align}\\]\nPlugin\n\\[\\begin{align}\nS_{i-2}a +T_{i-2}b = q_i\\left(S_{i-1}a + T_{i-1}b \\right) + r_i \\\\\nr_i = \\left(S_{i-2} - q_iS_{i-1}\\right) a + \\left(T_{i-2} - q_iT_{i-1}\\right) b\n\\end{align}\\]\nWhich gives\n\\[\\begin{align}\nS_i &= S_{i-2} - q_i S_{i-1} \\\\\nT_i &= T_{i-2} -q_i T_{i-1}\n\\end{align}\\]\n\\[\\begin{matrix}\na    &    b &   r & q & S  & T   \\\\\nx    &x     &   x & x & 1  & 0 \\\\\nx    &x     &   x & x & 0  & 1  \\\\\n2409 & 1023 & 363 & 2 & 1  & -2 \\\\\n1023 & 363  & 297 & 2 & -2 & 5  \\\\\n363  & 297  &  66 & 1 &  3 & -7 \\\\\n297  &  66  &  33 & 4 & -14& 33 \\\\\n66   &  33  &   0 & 2 &    &\n\\end{matrix}\\]\n\\(GCD = 33\\); \\(S = -14\\); \\(T = 33\\)\nThis process can be implemented as follows:\ndef Reset(S):\n   s = S[1]; S[0] = 1; S[1] = 0\n   return s\ndef Iterate(S, q):\n   s = S[0]\n   S[0] = S[1]\n   S[1] = s - q*S[1]\n   return S\ndef Extended_GCD(a, b, S = [1,0], T = [0,1]):\n   r = a%b\n   if r == 0:\n       return (b, Reset(S), Reset(T))\n   q = a//b\n   return Extended_GCD(b, r, Iterate(S,q), Iterate(T,q))\n\n\n\n",
    "preview": {},
    "last_modified": "2022-02-09T23:58:17-08:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-02-07-matlab/",
    "title": "MATLAB",
    "description": "A short description of the post.",
    "author": [
      {
        "name": "Skip Moses",
        "url": "https://example.com/norajones"
      }
    ],
    "date": "2022-02-07",
    "categories": [],
    "contents": "\nOverview\nToday I am going to attempt to learn MATLAB (Matrix Laboratory). MATLAB is a matrix based language geared towards engineers and scientists. With MATLAB one can\nAnalyze Data\nDevelop Algorithms\nCreate models and applications\nMy Goals\nFamilarize myself with basic syntax.\nLearn how to write simple loops and functions.\nLearn how to import and use scripts.\nLearn how to write a matrix to a text file.\nI need MATLAB so I can run the algorithm from Dong et. al. and compare results with my version that is implemented in python.\nMy hope is learning basic MATLAB will give me a clearer understanding of the algorithm.\nPlan\nI will watch this video, and follow along to accomplish goal 1.\nI will write some simple loops and functions for goal 2.\nI will put these functions in a script and attempt to run it.\nI will get Dong et. al. algorithm running.\nNotes\nOpening MATLAB for the first time\nWhen you open MATLAB most of the screen will be occupied by the Command Window. This functions much like the terminal with python. Here you can input simple commands. The Current Folder will show your current working directory. Notice this is very similar to RStudio. The Workspace window will show values of variables. The PLOT tab is where graphics will be displayed, and the APP tab will show different apps you can add (similar to adding packages in R).\nThe Command Window and Workspace will be the most important.\nSome common operations\nThe basic arithmetic opperations for python are +, -, *, and /. The ‘=’ sign is used for assignment.\ndouble clicking the top of a window will enlarge and minimize it.\nIf we enlarge the **Workspace*, we can right click (control click on macbook) and select several different properties to be displayed.\nWe can clear our command window by running the command ‘clc’. We can in turn hit the up arrow key to scroll through all previous commands that have been run in a given session.\nRunning the command ‘whos’ will display the workspace.\nIf we want to clear our workspace we can use the command ‘clear all’. We can delete a single variable, ‘a’, by the command ‘clear a’.\nUnderstanding Variables\nBy default, every variable defined in MATLAB will be a matrix. When we assign a single integer to a variable, MATLAB stores this as \\(1\\times 1\\) matrix.\nWe can create a matrix of arbitrary size by:\n‘a = [ 9 8 8;]’\nwill creat a \\(1\\times 3\\) matrix.\n‘a = [ 1 1 1; 2 2 2; 3 3 3;]’\nwill create the matrix:\n\\[\\begin{bmatrix}\n1&1&1\\\\\n2&2&2\\\\\n3&3&3\\\\\n\\end{bmatrix}\\]\nIf we now expand our workspace, we can click on our variable ‘a’, and see the matrix displayed in an excel-like grid. We can now use some of the other attributes in our workspace like min, max, mean, median, ect.\nWe can right click our variable in our workspace and preform some useful operations like; rename it, change its value, duplicate it and make various plots if its is the correct size.\nWe can also save the variable as .mat file.\nWe can load a .mat file with the ‘load(FILENAME.mat)’.\nDifferent Types of Variables\nSo far, we have only used numeric variables. We can have character variables char. The command\na = ‘hello world’\nwill create a \\(1\\times 11\\) character matrix.\nWe can add a row to matrix, a, with the following:\na(2,:) = a(1,:)\nThis will output\n‘hello world’\n‘hello world’\nNote: you must make sure the rows are the same size when adding them\nWe can get around this by using strings.\nWe can create an empty string with:\na = [string(‘Hi how ar you’) string(‘hello world’)]\noutput:\na =\n1×2 string array\n\"Hi how ar you\"    \"hello world\"\n\n\n\n",
    "preview": {},
    "last_modified": "2022-02-09T23:30:32-08:00",
    "input_file": {}
  },
  {
    "path": "posts/welcome/",
    "title": "Welcome to Today I am Learning",
    "description": "Welcome to our new blog, Today I am Learning. We hope you enjoy \nreading what we have to say!",
    "author": [
      {
        "name": "Skip Moses",
        "url": "https://example.com/norajones"
      }
    ],
    "date": "2022-02-07",
    "categories": [],
    "contents": "\n\n\n\n",
    "preview": {},
    "last_modified": "2022-02-09T23:30:32-08:00",
    "input_file": {}
  }
]
